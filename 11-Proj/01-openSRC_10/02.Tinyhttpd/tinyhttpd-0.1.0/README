  This software is copyright 1999 by J. David Blackstone.  Permission
is granted to redistribute and modify this software under the terms of
the GNU General Public License, available at http://www.gnu.org/ .

  If you use this software or examine the code, I would appreciate
knowing and would be overjoyed to hear about it at
jdavidb@sourceforge.net .

  This software is not production quality.  It comes with no warranty
of any kind, not even an implied warranty of fitness for a particular
purpose.  I am not responsible for the damage that will likely result
if you use this software on your computer system.

  I wrote this webserver for an assignment in my networking class in
1999.  We were told that at a bare minimum the server had to serve
pages, and told that we would get extra credit for doing "extras."
Perl had introduced me to a whole lot of UNIX functionality (I learned
sockets and fork from Perl!), and O'Reilly's lion book on UNIX system
calls plus O'Reilly's books on CGI and writing web clients in Perl got
me thinking and I realized I could make my webserver support CGI with
little trouble.

  Now, if you're a member of the Apache core group, you might not be
impressed.  But my professor was blown over.  Try the color.cgi sample
script and type in "chartreuse."  Made me seem smarter than I am, at
any rate. :)

  Apache it's not.  But I do hope that this program is a good
educational tool for those interested in http/socket programming, as
well as UNIX system calls.  (There's some textbook uses of pipes,
environment variables, forks, and so on.)

  One last thing: if you look at my webserver or (are you out of
mind?!?) use it, I would just be overjoyed to hear about it.  Please
email me.  I probably won't really be releasing major updates, but if
I help you learn something, I'd love to know!

  Happy hacking!

                                   J. David Blackstone

====================================================================
工作流程：

1>服务器启动，在指定端口或随机选取端口绑定httpd服务。

2>收到一个http请求时(其实就是listen端口accept的时候)，派生一个线程运
行accept_request函数。

3>取出http请求中method(get或post)和url,对于get方法，如果有携带参数，
则query_string指针指向url中?后面的get参数。

4>格式化url到path数组，表示浏览器请求的文件路径，在tinyhttpd中服务器
文件是在htdocs文件夹下。当url以/结尾，或者url是个目录，则默认在path中
加上index.thml，表示访问主页。

5>如果文件路径合法，对于无参数的get请求，直接输出服务器文件到浏览器，即用
http格式写到套接字上，跳到(10)。其他情况(带参数get，post方法，url为科执行
        文件)，则调用execute_cgi函数执行cgi脚本。

6>读取整个http请求并丢弃，如果是post则找出content-length，把http状态
码200写到套接字里面。

7>建立两个管道，cgi_input和cgi_output,并fork一个子进程。

8>在子进程中，把stdout重定向到cgi_output的写入端，把stdin重定向到
cgi_input的读取端，关闭cgi_input的写入端和cgi_output的读取端，是指
request_method的环境变量，get的话设置query_string的环境变量，post的话
设置content-length的环境变量，这些环境变量都是为了给cgi脚本调用，接着
用execl运行cgi程序。

9>在父进程中，关闭cgi_input的读取端和cgi_output的写入端，如果post的话，
把post数据写入到cgo_input，已被重定向到stdin读取cgi_output的管道输出到
客户端，等待子进程结束。

10>关闭与浏览器的链接，完成一次http请求与回应，因为http是无连接的。
